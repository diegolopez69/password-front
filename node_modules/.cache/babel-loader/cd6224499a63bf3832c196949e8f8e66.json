{"remainingRequest":"/home/caillou/Desktop/password-front/node_modules/babel-loader/lib/index.js!/home/caillou/Desktop/password-front/node_modules/vuetify/lib/util/mergeData.js","dependencies":[{"path":"/home/caillou/Desktop/password-front/node_modules/vuetify/lib/util/mergeData.js","mtime":499162500000},{"path":"/home/caillou/Desktop/password-front/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/caillou/Desktop/password-front/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:InVzZSBzdHJpY3QiOwoKT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgewogIHZhbHVlOiB0cnVlCn0pOwpleHBvcnRzLmRlZmF1bHQgPSBtZXJnZURhdGE7CmV4cG9ydHMubWVyZ2VTdHlsZXMgPSBtZXJnZVN0eWxlczsKZXhwb3J0cy5tZXJnZUNsYXNzZXMgPSBtZXJnZUNsYXNzZXM7CmV4cG9ydHMubWVyZ2VMaXN0ZW5lcnMgPSBtZXJnZUxpc3RlbmVyczsKCnZhciBfaGVscGVycyA9IHJlcXVpcmUoIi4vaGVscGVycyIpOwoKY29uc3QgcGF0dGVybiA9IHsKICBzdHlsZUxpc3Q6IC87KD8hW14oXSpcKSkvZywKICBzdHlsZVByb3A6IC86KC4qKS8KfTsKCmZ1bmN0aW9uIHBhcnNlU3R5bGUoc3R5bGUpIHsKICBjb25zdCBzdHlsZU1hcCA9IHt9OwoKICBmb3IgKGNvbnN0IHMgb2Ygc3R5bGUuc3BsaXQocGF0dGVybi5zdHlsZUxpc3QpKSB7CiAgICBsZXQgW2tleSwgdmFsXSA9IHMuc3BsaXQocGF0dGVybi5zdHlsZVByb3ApOwogICAga2V5ID0ga2V5LnRyaW0oKTsKCiAgICBpZiAoIWtleSkgewogICAgICBjb250aW51ZTsKICAgIH0gLy8gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgYGtleTogdmFsdWVgIHBhaXIgaXMgaW5jb21wbGV0ZS4KCgogICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7CiAgICAgIHZhbCA9IHZhbC50cmltKCk7CiAgICB9CgogICAgc3R5bGVNYXBbKDAsIF9oZWxwZXJzLmNhbWVsaXplKShrZXkpXSA9IHZhbDsKICB9CgogIHJldHVybiBzdHlsZU1hcDsKfQoKZnVuY3Rpb24gbWVyZ2VEYXRhKCkgewogIGNvbnN0IG1lcmdlVGFyZ2V0ID0ge307CiAgbGV0IGkgPSBhcmd1bWVudHMubGVuZ3RoOwogIGxldCBwcm9wOyAvLyBBbGxvdyBmb3IgdmFyaWFkaWMgYXJndW1lbnQgbGVuZ3RoLgoKICB3aGlsZSAoaS0tKSB7CiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGRhdGEgcHJvcGVydGllcyBhbmQgZXhlY3V0ZSBtZXJnZSBzdHJhdGVnaWVzCiAgICAvLyBPYmplY3Qua2V5cyBlbGltaW5hdGVzIG5lZWQgZm9yIGhhc093blByb3BlcnR5IGNhbGwKICAgIGZvciAocHJvcCBvZiBPYmplY3Qua2V5cyhhcmd1bWVudHNbaV0pKSB7CiAgICAgIHN3aXRjaCAocHJvcCkgewogICAgICAgIC8vIEFycmF5IG1lcmdlIHN0cmF0ZWd5IChhcnJheSBjb25jYXRlbmF0aW9uKQogICAgICAgIGNhc2UgJ2NsYXNzJzoKICAgICAgICBjYXNlICdkaXJlY3RpdmVzJzoKICAgICAgICAgIGlmIChhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSBtZXJnZUNsYXNzZXMobWVyZ2VUYXJnZXRbcHJvcF0sIGFyZ3VtZW50c1tpXVtwcm9wXSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJ3N0eWxlJzoKICAgICAgICAgIGlmIChhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSBtZXJnZVN0eWxlcyhtZXJnZVRhcmdldFtwcm9wXSwgYXJndW1lbnRzW2ldW3Byb3BdKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBTcGFjZSBkZWxpbWl0ZWQgc3RyaW5nIGNvbmNhdGVuYXRpb24gc3RyYXRlZ3kKCiAgICAgICAgY2FzZSAnc3RhdGljQ2xhc3MnOgogICAgICAgICAgaWYgKCFhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKG1lcmdlVGFyZ2V0W3Byb3BdID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSAnJzsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAobWVyZ2VUYXJnZXRbcHJvcF0pIHsKICAgICAgICAgICAgLy8gTm90IGFuIGVtcHR5IHN0cmluZywgc28gY29uY2F0ZW5hdGUKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gKz0gJyAnOwogICAgICAgICAgfQoKICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdICs9IGFyZ3VtZW50c1tpXVtwcm9wXS50cmltKCk7CiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBPYmplY3QsIHRoZSBwcm9wZXJ0aWVzIG9mIHdoaWNoIHRvIG1lcmdlIHZpYSBhcnJheSBtZXJnZSBzdHJhdGVneSAoYXJyYXkgY29uY2F0ZW5hdGlvbikuCiAgICAgICAgLy8gQ2FsbGJhY2sgbWVyZ2Ugc3RyYXRlZ3kgbWVyZ2VzIGNhbGxiYWNrcyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSwKICAgICAgICAvLyBzbyB0aGF0IHRoZSBsYXN0IGRlZmluZWQgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIGZpcnN0LgogICAgICAgIC8vIFRoaXMgaXMgZG9uZSBzaW5jZSB0byBtaW1pYyBob3cgT2JqZWN0LmFzc2lnbiBtZXJnaW5nCiAgICAgICAgLy8gdXNlcyB0aGUgbGFzdCBnaXZlbiB2YWx1ZSB0byBhc3NpZ24uCgogICAgICAgIGNhc2UgJ29uJzoKICAgICAgICBjYXNlICduYXRpdmVPbic6CiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gbWVyZ2VMaXN0ZW5lcnMobWVyZ2VUYXJnZXRbcHJvcF0sIGFyZ3VtZW50c1tpXVtwcm9wXSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy8gT2JqZWN0IG1lcmdlIHN0cmF0ZWd5CgogICAgICAgIGNhc2UgJ2F0dHJzJzoKICAgICAgICBjYXNlICdwcm9wcyc6CiAgICAgICAgY2FzZSAnZG9tUHJvcHMnOgogICAgICAgIGNhc2UgJ3Njb3BlZFNsb3RzJzoKICAgICAgICBjYXNlICdzdGF0aWNTdHlsZSc6CiAgICAgICAgY2FzZSAnaG9vayc6CiAgICAgICAgY2FzZSAndHJhbnNpdGlvbic6CiAgICAgICAgICBpZiAoIWFyZ3VtZW50c1tpXVtwcm9wXSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoIW1lcmdlVGFyZ2V0W3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0ge307CiAgICAgICAgICB9CgogICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSB7IC4uLmFyZ3VtZW50c1tpXVtwcm9wXSwKICAgICAgICAgICAgLi4ubWVyZ2VUYXJnZXRbcHJvcF0KICAgICAgICAgIH07CiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBSZWFzc2lnbm1lbnQgc3RyYXRlZ3kgKG5vIG1lcmdlKQoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgLy8gc2xvdCwga2V5LCByZWYsIHRhZywgc2hvdywga2VlcEFsaXZlCiAgICAgICAgICBpZiAoIW1lcmdlVGFyZ2V0W3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gYXJndW1lbnRzW2ldW3Byb3BdOwogICAgICAgICAgfQoKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIG1lcmdlVGFyZ2V0Owp9CgpmdW5jdGlvbiBtZXJnZVN0eWxlcyh0YXJnZXQsIHNvdXJjZSkgewogIGlmICghdGFyZ2V0KSByZXR1cm4gc291cmNlOwogIGlmICghc291cmNlKSByZXR1cm4gdGFyZ2V0OwogIHRhcmdldCA9ICgwLCBfaGVscGVycy53cmFwSW5BcnJheSkodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyBwYXJzZVN0eWxlKHRhcmdldCkgOiB0YXJnZXQpOwogIHJldHVybiB0YXJnZXQuY29uY2F0KHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gcGFyc2VTdHlsZShzb3VyY2UpIDogc291cmNlKTsKfQoKZnVuY3Rpb24gbWVyZ2VDbGFzc2VzKHRhcmdldCwgc291cmNlKSB7CiAgaWYgKCFzb3VyY2UpIHJldHVybiB0YXJnZXQ7CiAgaWYgKCF0YXJnZXQpIHJldHVybiBzb3VyY2U7CiAgcmV0dXJuIHRhcmdldCA/ICgwLCBfaGVscGVycy53cmFwSW5BcnJheSkodGFyZ2V0KS5jb25jYXQoc291cmNlKSA6IHNvdXJjZTsKfQoKZnVuY3Rpb24gbWVyZ2VMaXN0ZW5lcnMoLi4uYXJncykgewogIGlmICghYXJnc1swXSkgcmV0dXJuIGFyZ3NbMV07CiAgaWYgKCFhcmdzWzFdKSByZXR1cm4gYXJnc1swXTsKICBjb25zdCBkZXN0ID0ge307CgogIGZvciAobGV0IGkgPSAyOyBpLS07KSB7CiAgICBjb25zdCBhcmcgPSBhcmdzW2ldOwoKICAgIGZvciAoY29uc3QgZXZlbnQgaW4gYXJnKSB7CiAgICAgIGlmICghYXJnW2V2ZW50XSkgY29udGludWU7CgogICAgICBpZiAoZGVzdFtldmVudF0pIHsKICAgICAgICAvLyBNZXJnZSBjdXJyZW50IGxpc3RlbmVycyBiZWZvcmUgKGJlY2F1c2Ugd2UgYXJlIGl0ZXJhdGluZyBiYWNrd2FyZHMpLgogICAgICAgIC8vIE5vdGUgdGhhdCBuZWl0aGVyICJ0YXJnZXQiIG9yICJzb3VyY2UiIG11c3QgYmUgYWx0ZXJlZC4KICAgICAgICBkZXN0W2V2ZW50XSA9IFtdLmNvbmNhdChhcmdbZXZlbnRdLCBkZXN0W2V2ZW50XSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gU3RyYWlnaHQgYXNzaWduLgogICAgICAgIGRlc3RbZXZlbnRdID0gYXJnW2V2ZW50XTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIGRlc3Q7Cn0="},{"version":3,"sources":["../../src/util/mergeData.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize, wrapInArray } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        default: // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n\nexport function mergeStyles (\n  target: undefined | string | object[] | object,\n  source: undefined | string | object[] | object\n) {\n  if (!target) return source\n  if (!source) return target\n\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target)\n\n  return (target as object[]).concat(typeof source === 'string' ? parseStyle(source) : source)\n}\n\nexport function mergeClasses (target: any, source: any) {\n  if (!source) return target\n  if (!target) return source\n\n  return target ? wrapInArray(target).concat(source) : source\n}\n\nexport function mergeListeners (...args: [\n  { [key: string]: Function | Function[] } | undefined,\n  { [key: string]: Function | Function[] } | undefined\n]) {\n  if (!args[0]) return args[1]\n  if (!args[1]) return args[0]\n\n  const dest: { [key: string]: Function | Function[] } = {}\n\n  for (let i = 2; i--;) {\n    const arg = args[i]\n    for (const event in arg) {\n      if (!arg[event]) continue\n\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = ([] as Function[]).concat(arg[event], dest[event])\n      } else {\n        // Straight assign.\n        dest[event] = arg[event]\n      }\n    }\n  }\n\n  return dest\n}\n"],"sourceRoot":""}]}